import type { IncomingMessage, ServerResponse } from 'node:http'

// This is the TanStack Start server entry generated by `vite build`.
// It exports `{ fetch(request: Request): Promise<Response> }`.
import server from '../dist/server/server.js'

function getRawBody(req: IncomingMessage): Promise<Uint8Array | undefined> {
  const method = (req.method ?? 'GET').toUpperCase()
  if (method === 'GET' || method === 'HEAD') return Promise.resolve(undefined)

  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = []
    req.on('data', (chunk) => chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk)))
    req.on('end', () => resolve(chunks.length ? Buffer.concat(chunks) : undefined))
    req.on('error', reject)
  })
}

function buildRequestUrl(req: IncomingMessage) {
  const forwardedProto = req.headers['x-forwarded-proto'] as string | undefined
  const proto =
    forwardedProto ?? ((req.socket as any)?.encrypted ? 'https' : 'http')
  const host =
    (req.headers['x-forwarded-host'] as string | undefined) ??
    (req.headers['host'] as string | undefined) ??
    'localhost'
  const path = (req.url as string | undefined) ?? '/'
  return `${proto}://${host}${path}`
}

export default async function handler(req: IncomingMessage, res: ServerResponse) {
  try {
    const url = buildRequestUrl(req)
    const body = await getRawBody(req)

    const headers = new Headers()
    for (const [k, v] of Object.entries(req.headers)) {
      if (typeof v === 'string') headers.set(k, v)
      else if (Array.isArray(v)) headers.set(k, v.join(', '))
    }

    const request = new Request(url, {
      method: req.method,
      headers,
      body: body ? body : undefined,
    })

    const response = await server.fetch(request)

    res.statusCode = response.status
    response.headers.forEach((value, key) => {
      // Node expects `set-cookie` as an array if multiple; Start typically sets 0/1.
      res.setHeader(key, value)
    })

    const buf = Buffer.from(await response.arrayBuffer())
    res.end(buf)
  } catch (err) {
    res.statusCode = 500
    res.setHeader('content-type', 'text/plain; charset=utf-8')
    res.end(`Server error: ${(err as Error)?.message ?? String(err)}`)
  }
}


